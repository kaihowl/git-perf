================================================================================
                    GIT-PERF CODEBASE ARCHITECTURE SUMMARY
================================================================================

PROJECT: git-perf - Performance Measurement Tracking with Git Notes
LANGUAGE: Rust (Edition 2021)
TOTAL LINES: ~6,500 core code + 600+ git operations
WORKSPACE: Two-crate (cli_types + git_perf)

================================================================================
                            DATA FLOW ARCHITECTURE
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│                          USER INTERACTION LAYER                             │
├─────────────────────────────────────────────────────────────────────────────┤
│ CLI (cli.rs ~500L)                                                          │
│  ├── measure <command>       - Time a command (n reps)                      │
│  ├── add <value>             - Add single measurement                       │
│  ├── import <format> <file>  - JUnit XML or Criterion JSON                  │
│  ├── audit [-m measure]      - Regression detection (MAIN ANALYSIS)         │
│  ├── report [-m measure]     - HTML+CSV reporting                           │
│  ├── bump-epoch              - Accept regression, reset baseline            │
│  └── [push/pull/remove/...]  - Data management commands                     │
└─────────────────────────────────────────────────────────────────────────────┘
                                     |
                    ┌────────────────┼────────────────┐
                    |                |                |
        ┌───────────▼──┐  ┌──────────▼────┐  ┌──────▼──────────┐
        │  STORAGE     │  │  IMPORT/PARSE │  │  CONFIGURATION │
        │  LAYER       │  │  LAYER        │  │  LAYER         │
        └──────────────┘  └───────────────┘  └─────────────────┘
                 |               |                      |
        ┌────────▼────────┐      |         ┌────────────▼────────┐
        │measurement_     │      |         │config.rs (1,118L)  │
        │storage.rs       │      |         │ ├─ Hierarchical    │
        │ ├─add()         │      |         │ ├─ Per-measurement  │
        │ └─serialize()   │      |         │ ├─ System-wide      │
        └────────┬────────┘      |         │ └─ Built-in        │
                 |               |         └─────────────────────┘
        ┌────────▼─────────────────┐
        │ serialization.rs (343L)  │
        │ ├─ Encode/decode         │
        │ └─ Format: epoch|name|ts│val|k=v
        │    (null-byte delimited) │
        └────────┬──────────────────┘
                 |
        ┌────────▼─────────────────┐
        │ git_interop.rs (~400L)   │
        │ ├─ Git notes append      │
        │ ├─ Backoff retry logic   │
        │ └─ refs/notes/perf-v3    │
        └──────────────────────────┘
                 |
              GIT DB
             (notes)

================================================================================
                        RETRIEVAL & ANALYSIS PIPELINE
================================================================================

┌────────────────────────────────────────────────────────────────────────────┐
│                        ANALYSIS LAYER (CORE)                               │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  audit.rs (1,501L) - MAIN STATISTICAL ENGINE                               │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │ Phase 1: Data Aggregation                                            │  │
│  │  • Walk commits (HEAD backwards)                                     │  │
│  │  • Filter by measurement name/pattern + selectors                   │  │
│  │  • Aggregate per-commit (Min/Max/Median/Mean)                       │  │
│  │  • Stop at epoch boundary                                           │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                            ↓                                                 │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │ Phase 2: Statistical Testing                                         │  │
│  │  • Separate HEAD (current) from TAIL (historical)                   │  │
│  │  • Calculate z-score: |head - tail_mean| / dispersion               │  │
│  │  • Dispersion = stddev (outlier-sensitive) OR mad (robust)          │  │
│  │  • Compare to sigma threshold                                       │  │
│  │  • Apply min_relative_deviation threshold (optional)                │  │
│  │  • Result: PASS/FAIL + statistics                                   │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                            ↓                                                 │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │ Phase 3: Output Generation                                           │  │
│  │  • Format results: ✅ or ❌ + direction arrow                         │  │
│  │  • Sparkline visualization (ASCII)                                  │  │
│  │  • Range display (min/max % vs tail median)                         │  │
│  │  • Unit formatting (from config)                                    │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└────────────────────────────────────────────────────────────────────────────┘

SUPPORTING MODULES:

  measurement_retrieval.rs (93L)
  ├─ walk_commits(n)                   - Iterator over commits
  ├─ summarize_measurements(...)       - Aggregation pipeline
  └─ take_while_same_epoch(iter)       - Epoch boundary handling

  stats.rs (757L) - STATISTICAL CALCULATIONS
  ├─ Stats struct:
  │  ├─ mean, stddev, mad, len
  │  ├─ z_score_with_method()
  │  └─ is_significant()
  ├─ aggregate_measurements()           - Mean + Variance from iterator
  ├─ calculate_mad()                    - Median Absolute Deviation
  └─ VecAggregation trait
     └─ median()                        - Sorted median calculation

  filter.rs (162L)
  ├─ compile_filters()                 - Regex pattern compilation
  ├─ matches_any_filter()              - OR logic matching
  └─ measurements_to_anchored_regex()  - Exact matching

================================================================================
                         OUTPUT & REPORTING LAYER
================================================================================

reporting.rs (976L) - VISUALIZATION & EXPORT
├─ PlotlyReporter (HTML/Interactive)
│  ├─ Plots with reversed X-axis (newest right)
│  ├─ Multiple traces (grouped by metadata)
│  ├─ Auto unit labeling on Y-axis
│  └─ Responsive design
├─ CsvMeasurementRow (Tab-delimited export)
│  ├─ commit | epoch | measurement | timestamp | value | unit | metadata...
│  └─ Full precision in data
└─ Report generation
   ├─ Filter measurements
   ├─ Group by metadata
   └─ Generate HTML + CSV

units.rs (263L) - UNIT HANDLING
├─ Time: ns, us, ms, s
├─ Size: B, KB, MB, GB
├─ Count: #
└─ Auto-scaling with human-readable formatting

================================================================================
                         DATA STRUCTURES OVERVIEW
================================================================================

MeasurementData (data.rs)
├─ epoch: u32              ← Config-determined baseline version
├─ name: String            ← Measurement identifier
├─ timestamp: f64          ← Unix seconds when recorded
├─ val: f64                ← Numeric measurement value
└─ key_values: HashMap     ← Metadata (os, arch, branch, etc.)

CommitSummary (created during analysis)
├─ commit: String          ← Git SHA
└─ measurement: Option<MeasurementSummary>
   ├─ epoch: u32
   └─ val: f64             ← Aggregated value

================================================================================
                    CONFIGURATION HIERARCHY (config.rs)
================================================================================

Priority (high to low):
  1. CLI flags        (--sigma, --dispersion-method, etc.)
  2. Measurement-specific config  ([measurement."name"])
  3. Default config   ([measurement])
  4. System-wide      (~/.config/git-perf/config.toml)
  5. Built-in defaults

Configurable Parameters:
├─ Audit:
│  ├─ sigma (z-score threshold, default 4.0)
│  ├─ min_measurements (minimum historical points, default 2)
│  ├─ dispersion_method (stddev or mad, default stddev)
│  ├─ aggregate_by (Min/Max/Median/Mean, default Min)
│  └─ min_relative_deviation (optional noise threshold)
├─ Measurement:
│  └─ unit (ns, ms, bytes, etc.)
└─ Epoch:
   └─ Version number (reset baseline at threshold)

================================================================================
                    MODULE DEPENDENCY GRAPH
================================================================================

audit.rs (1,501L) - DEPENDS ON
├─ measurement_retrieval.rs
├─ stats.rs
├─ config.rs
├─ filter.rs
└─ data.rs

reporting.rs (976L) - DEPENDS ON
├─ measurement_retrieval.rs
├─ data.rs
├─ config.rs
├─ units.rs
└─ plotly (external)

import.rs (607L) - DEPENDS ON
├─ measurement_storage.rs
├─ config.rs
├─ filter.rs
└─ quick_xml, serde_json (external)

measurement_storage.rs - DEPENDS ON
├─ git_interop.rs
├─ serialization.rs
└─ config.rs

measurement_retrieval.rs - DEPENDS ON
├─ git_interop.rs
├─ serialization.rs
└─ stats.rs

stats.rs - DEPENDS ON
├─ itertools
└─ average (external)

filter.rs - DEPENDS ON
└─ regex (external)

================================================================================
                        AUDIT SYSTEM LOGIC FLOW
================================================================================

Input: measurement_name, historical_depth (max_count), selectors

Step 1: PREPARATION
  ├─ Load commits from HEAD backwards
  ├─ Deserialize measurements from git notes
  └─ Build list of measurements to audit

Step 2: FOR EACH MEASUREMENT:
  ├─ Retrieve measurement-specific config
  │  ├─ Resolve min_count (CLI > config > built-in)
  │  ├─ Resolve sigma (CLI > config > built-in)
  │  ├─ Resolve dispersion_method (CLI > config > built-in)
  │  └─ Resolve aggregate_by (CLI > config > built-in)
  │
  ├─ Filter & aggregate commits:
  │  ├─ Keep only matching measurements
  │  ├─ Aggregate by reduction function
  │  └─ Stop at epoch boundary
  │
  ├─ Separate into HEAD + TAIL:
  │  ├─ HEAD = current commit value
  │  └─ TAIL = all historical values
  │
  ├─ Check minimum threshold:
  │  └─ if tail.len < min_count → SKIP
  │
  ├─ Calculate statistics:
  │  ├─ HEAD: Stats { mean: val, stddev: 0, mad: 0, len: 1 }
  │  └─ TAIL: Stats { mean, stddev, mad, len }
  │
  ├─ Calculate z-score:
  │  ├─ z = |head.mean - tail.mean| / dispersion
  │  └─ dispersion = stddev or mad (from config)
  │
  ├─ Check significance:
  │  ├─ if z > sigma → significant (potential regression)
  │  └─ else → not significant
  │
  ├─ Apply relative deviation threshold (optional):
  │  ├─ relative_dev = |(head / tail_median - 1)| * 100
  │  ├─ if relative_dev < min_relative_deviation → PASS
  │  └─ else → FAIL
  │
  ├─ Generate sparkline & output:
  │  ├─ Show range: [min% – max%] ▁▂▃▄▅▆▇█
  │  ├─ Show direction: ↑ (higher), ↓ (lower), → (same)
  │  ├─ Format unit with μ, σ, MAD
  │  └─ Print result: ✅ or ❌
  │
  └─ Aggregate result: passed = !z_exceeds_sigma || relative_threshold_ok

Output: One result per measurement (✅ or ❌), failure if any failed

================================================================================
                    CHANGE POINT DETECTION OPPORTUNITIES
================================================================================

WHERE TO INTEGRATE:

  Option A: EXTENDED AUDIT ANALYSIS
    ├─ Location: audit.rs, after z-score calculation (line ~400)
    ├─ Trigger: When tail.len > threshold (e.g., 10 measurements)
    ├─ Output: "Change detected at commit X with ~20% regression"
    └─ Benefit: Complements z-score testing

  Option B: ALTERNATIVE ANALYSIS MODE
    ├─ New module: change_point.rs (~300-500 lines)
    ├─ New command: audit --detect-changes or analyze-change-points
    ├─ Input: Same data pipeline (measurement_retrieval + filtering)
    └─ Output: List of detected changes with metadata

  Option C: REPORT ENHANCEMENT
    ├─ Location: reporting.rs, HTML generation
    ├─ Visual: Markers on graph at detected change points
    └─ CSV: Additional columns for change point info

  Option D: AUTO-EPOCH DETECTION
    ├─ Purpose: Automatic baseline reset (replace bump-epoch)
    ├─ Integration: bump-epoch command enhancement
    └─ Benefit: Intelligent epoch management

DATA AVAILABLE FOR CHANGE POINT DETECTION:

  From measurement_retrieval pipeline:
  ├─ Time series: Vec<f64> of 10-40 measurements
  ├─ Chronological order: HEAD backwards (reverse chronological)
  ├─ Pre-aggregated: Already reduced by Min/Max/Median/Mean
  ├─ Filtered: Only matching measurements
  ├─ Epoch-aware: Stops at epoch boundary
  └─ Metadata: Key-value pairs for grouping

  From stats module (available functions):
  ├─ mean, stddev, mad calculations
  ├─ VecAggregation trait (median)
  ├─ Iteration and reduction operators
  └─ Z-score infrastructure (can be repurposed)

================================================================================
                             KEY INSIGHTS
================================================================================

1. WELL-STRUCTURED FOR ENHANCEMENT
   • Clear module boundaries
   • Iterator-based design (composable)
   • Trait-based abstraction (extensible)
   • Configuration system already mature

2. STATISTICAL FOUNDATION READY
   • Mean, variance, stddev, MAD calculations available
   • Z-score testing infrastructure established
   • Two dispersion methods already implemented
   • Statistical testing well-tested (mutation testing)

3. DATA ACCESS PATTERNS ESTABLISHED
   • walk_commits() → Iterator<Result<Commit>>
   • summarize_measurements() → aggregation pipeline
   • take_while_same_epoch() → handles boundaries
   • filter system → measurement selection

4. OUTPUT INFRASTRUCTURE READY
   • Audit message formatting
   • Sparkline generation (sparklines crate)
   • CSV export structure
   • HTML report generation (Plotly)

5. CONFIGURATION LEVERAGE POTENTIAL
   • Hierarchical config with measurement-specific overrides
   • Can reuse sigma for algorithm parameters
   • Unit system for result formatting
   • Built-in defaults with CLI override

================================================================================
                              FILE LOCATIONS
================================================================================

Core Implementation Files:
  /root/repo/git_perf/src/audit.rs                 (1,501 lines)
  /root/repo/git_perf/src/stats.rs                 (757 lines)
  /root/repo/git_perf/src/measurement_retrieval.rs (93 lines)
  /root/repo/git_perf/src/config.rs                (1,118 lines)
  /root/repo/git_perf/src/reporting.rs             (976 lines)
  /root/repo/git_perf/src/cli.rs                   (~500 lines)

Supporting Files:
  /root/repo/git_perf/src/data.rs
  /root/repo/git_perf/src/serialization.rs
  /root/repo/git_perf/src/filter.rs
  /root/repo/git_perf/src/measurement_storage.rs
  /root/repo/git_perf/src/units.rs
  /root/repo/git_perf/src/import.rs
  /root/repo/git_perf/src/git/

Test & Configuration:
  /root/repo/git_perf/tests/bash_tests.rs
  /root/repo/git_perf/benches/
  /root/repo/.gitperfconfig (example config)

================================================================================
