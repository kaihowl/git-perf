#!/usr/bin/env python3

import argparse
import time
import subprocess
from typing import List, Tuple
import sys
import pandas as pd  # type: ignore
import plotly.express as px  # type: ignore

PERF_REF = 'refs/notes/perf'
MAX_PUSHES = 3
DEFAULT_MAX_COUNT = 40

# TODO(kaihowl) select perf by key value

parser = argparse.ArgumentParser()
sub_parser = parser.add_subparsers(dest='subcommand')


def numeric(val):
    try:
        float(val)
    except ValueError:
        raise argparse.ArgumentTypeError(f"'{val}' is not numeric")

    # Keep as string, this is parsed in Pandas to the most appropriate type
    return val


def add_measurement_option(parser):
    parser.add_argument(
        '--measurement', '-m', help='Name of measurement', required=True,
        dest='measurement')


def keyvalue(val) -> Tuple[str, str]:
    if len(val.split()) != 1:
        raise argparse.ArgumentTypeError(f"Key value pair '{val}' contains whitespace")

    split = val.strip().split('=')
    if len(split) != 2:
        raise argparse.ArgumentTypeError(
            f"Key value pair '{val}' does not follow 'key=value' format")

    return split


def add_kv_option(parser):
    parser.add_argument(
        '--key-value',
        '-kv',
        action='append',
        type=keyvalue,
        help='Key-value pair separated by "=" with no whitespaces',
        default=[])


# subcommand: measure
measure_parser = sub_parser.add_parser(
    "measure", help='Measure the supplied commands runtime')
add_kv_option(measure_parser)
add_measurement_option(measure_parser)
measure_parser.add_argument(
    '--number', '-n', help='Number of measurements', type=int, default=1)
measure_parser.add_argument(
    'command', nargs=argparse.REMAINDER, help='Command to measure')

# subcommand: add
add_parser = sub_parser.add_parser('add', help='Add single measurement')
add_kv_option(add_parser)
add_measurement_option(add_parser)
add_parser.add_argument('value', help='Measured value to be added (numeric)', type=numeric)

# subcommand: push
push_parser = sub_parser.add_parser(
    'push', help='Publish performance results to remote')

# TODO(kaihowl) report should have same parameters as audit
# subcommand: report
report_parser = sub_parser.add_parser(
    'report', help='Create an HTML performance report')
report_parser.add_argument(
    '-n',
    '--max-count',
    help='Limit to the number of previous commits considered',
    type=int,
    default=DEFAULT_MAX_COUNT)

# subcommand: audit
audit_parser = sub_parser.add_parser(
    'audit', help="""
    For a given measurement, check perfomance deviations of the HEAD commit
    against <n> previous commits. Group previous results and aggregate their
    results before comparison.
    """)
add_measurement_option(audit_parser)
audit_parser.add_argument(
    '--selector',
    '-s',
    action='append',
    type=keyvalue,
    help='Key-value pair separated by "=" with no whitespaces to subselect measurements',
    default=[])
audit_parser.add_argument(
    '-n',
    '--max-count',
    help='Limit to the number of previous commits considered',
    type=int,
    default=DEFAULT_MAX_COUNT)
audit_parser.add_argument(
    '-g',
    '--group-by',
    help='What to group the measurements by',
    default='commit')
audit_parser.add_argument(
    '-agg',
    '--aggregate-by',
    help='What to aggregate the measurements in each group with',
    default='min')


def measure(measurement: str, number: int, key_value: List[Tuple[str, str]], command: List[str]):
    for i in range(number):
        start = time.time_ns()
        subprocess.check_call(command)
        end = time.time_ns()
        value = end - start
        add(measurement, key_value, str(value))


def add(measurement: str, key_value: List[Tuple[str, str]], value: str):
    formatted_kvs = ' '.join([f"{key}={value}" for (key, value) in key_value])
    formatted_measurement = f"{measurement} {time.time()} {value} {formatted_kvs}"
    print(formatted_measurement)

    notes_call = ['git', 'notes', '--ref', PERF_REF,
                  'append', '-m', formatted_measurement]
    subprocess.check_call(notes_call)


def push():
    counter = 0
    while counter < MAX_PUSHES and push_to_origin() != 0:
        fetch()
        reconcile()
        counter += 1


def push_to_origin() -> int:
    return subprocess.call(['git', 'push', 'origin', PERF_REF])


def fetch():
    subprocess.check_call(['git', 'fetch', 'origin', PERF_REF])


def reconcile():
    subprocess.check_call(['git',
                           'notes',
                           '--ref',
                           PERF_REF,
                           'merge',
                           '-s',
                           'cat_sort_uniq',
                           'FETCH_HEAD'])


def get_raw_notes(max_count_commits: int) -> str:
    command = ['git',
               '--no-pager',
               'log',
               '-n', str(max_count_commits),
               '--no-color',
               '--pretty=-- %H%n%N',
               f"--notes={PERF_REF}"]
    print(" ".join(command))
    return subprocess.check_output(command, text=True)


def get_df(max_count_commits: int):
    records = []
    commit = None
    for line in get_raw_notes(max_count_commits).splitlines():
        if line.startswith('--'):
            commit = line.split(" ")[1].strip()
            continue
        if len(line.strip()) == 0:
            continue
        if commit is None:
            print(
                f"Already have input but commit is unknown: ''", file=sys.stderr)
            assert(False)
            continue
        data = line.strip()
        items = data.split()
        if len(items) < 3:
            print(
                f"Too few items for commit in input line: '{data}'", file=sys.stderr)
            assert(False)
            continue
        name = items[0]
        time = items[1]
        val = items[2]
        # TODO(kaihowl) fix up check
        if not val.isnumeric():
            print(
                f"Found non-numeric value '{val}' as measurement for commit {commit} in line: '{data}'", file=sys.stderr)
            assert(False)
            continue
        kvs = items[3:]
        records.append({"commit": commit, "name": name, "time": pd.to_datetime(
            time, unit='s'), "val": float(val), "kvs": kvs})
    # TODO(kaihowl) handle and test empty records
    df = pd.DataFrame(records)

    df.index.name = 'num'
    if 'kvs' in df.columns:
        df = df.join(df.kvs.explode().str.split(
            '=', expand=True).pivot_table(columns=0, index='num', values=1, aggfunc='last'))
        df = df.drop(['kvs'], axis=1)
    return df


def report(max_count: int):
    df = get_df(max_count)
    if 'os' in df.columns and 'runner_os' in df.columns:
        df['os'] = df['os'].fillna(df['runner_os'])
    df = df.fillna("n/a")
    print(df.to_markdown())
    args = {
        'x': 'time',
        'y': 'val',
        'color': 'name',
        'hover_data': df.columns,
    }
    if 'os' in df.columns:
        args['symbol'] = 'os'
    if (len(df) == 0):
        print("No performance measurements found", file=sys.stderr)
        sys.exit(1)
    # TODO(kaihowl) make configurable
    px.scatter(df, **args).write_html('result.html')


# TODO(kaihowl) how to pass / select last value? Just use commit on top compared to <n> previous?
def audit(measurement: str,
          max_count: int,
          group_by: str,
          aggregate_by: str,
          selector: List[Tuple[str, str]]):
    # HEAD commit + max_count == max_count + 1 for the final count
    df = get_df(max_count + 1)
    selector.append(('name', measurement))
    # TODO(kaihowl) handle non-existent selectors
    for (key, value) in selector:
        df = df[df[key] == value]
    print(df.groupby(group_by).val.agg(aggregate_by).mean())


if __name__ == '__main__':
    args = parser.parse_args()
    subcommand = args.subcommand
    del args.subcommand
    locals()[subcommand](**vars(args))
