#!/usr/bin/env python3

import argparse
import time
import subprocess
from typing import List, Tuple
import sys

PERF_REF = 'refs/notes/perf'
MAX_PUSHES = 3
DEFAULT_MAX_COUNT = 40

KeyValueList = List[Tuple[str, str]]

parser = argparse.ArgumentParser()
sub_parser = parser.add_subparsers(dest='subcommand', required=True)


def isnumeric(val: str):
    try:
        float(val)
    except ValueError:
        return False

    return True


def numerictype(val):
    if not isnumeric(val):
        raise argparse.ArgumentTypeError(f"'{val}' is not numeric")

    # Keep as string, this is parsed in Pandas to the most appropriate type
    return val


def add_measurement_option(parser):
    parser.add_argument(
        '--measurement', '-m', help='Name of measurement', required=True,
        dest='measurement')


def keyvalue(val) -> Tuple[str, str]:
    if len(val.split()) != 1:
        raise argparse.ArgumentTypeError(f"Key value pair '{val}' contains whitespace")

    split = val.strip().split('=')
    if len(split) != 2:
        raise argparse.ArgumentTypeError(
            f"Key value pair '{val}' does not follow 'key=value' format")

    return split


def add_kv_option(parser):
    parser.add_argument(
        '--key-value',
        '-kv',
        action='append',
        type=keyvalue,
        help='Key-value pair separated by "=" with no whitespaces',
        default=[])


# subcommand: measure
measure_parser = sub_parser.add_parser(
    "measure", help='Measure the supplied commands runtime')
add_kv_option(measure_parser)
add_measurement_option(measure_parser)
measure_parser.add_argument(
    '--number', '-n', help='Number of measurements', type=int, default=1)
measure_parser.add_argument(
    'command', nargs=argparse.REMAINDER, help='Command to measure')

# subcommand: add
add_parser = sub_parser.add_parser('add', help='Add single measurement')
add_kv_option(add_parser)
add_measurement_option(add_parser)
add_parser.add_argument('value', help='Measured value to be added (numeric)', type=numerictype)

# subcommand: push
push_parser = sub_parser.add_parser(
    'push', help='Publish performance results to remote')

# subcommand: push
pull_parser = sub_parser.add_parser(
    'pull', help='Pull performance results from remote')

# TODO(kaihowl) report should have same parameters as audit
# subcommand: report
report_parser = sub_parser.add_parser(
    'report', help='Create an HTML performance report')
report_parser.add_argument('-o', '--output', help='HTML output file', default='result.html')
report_parser.add_argument(
    '-n',
    '--max-count',
    help='Limit to the number of previous commits considered',
    type=int,
    default=DEFAULT_MAX_COUNT)

# subcommand: audit
audit_parser = sub_parser.add_parser(
    'audit', help="""
    For a given measurement, check perfomance deviations of the HEAD commit
    against <n> previous commits. Group previous results and aggregate their
    results before comparison.
    """)
add_measurement_option(audit_parser)
audit_parser.add_argument(
    '--selector',
    '-s',
    action='append',
    type=keyvalue,
    help='Key-value pair separated by "=" with no whitespaces to subselect measurements',
    default=[])
audit_parser.add_argument(
    '-n',
    '--max-count',
    help='Limit to the number of previous commits considered',
    type=int,
    default=DEFAULT_MAX_COUNT)
audit_parser.add_argument(
    '-g',
    '--group-by',
    help='What to group the measurements by',
    default='commit')
audit_parser.add_argument(
    '-agg',
    '--aggregate-by',
    help='What to aggregate the measurements in each group with',
    default='min')
audit_parser.add_argument(
    '-d', '--sigma',
    help='Multiple of the stddev after which a outlier is detected. '
    'If the HEAD measurement is within [mean-<d>*sigma; mean+<d>*sigma], '
    'it is considered acceptable.',
    type=float,
    default=4)


def measure(measurement: str, number: int, key_value: KeyValueList, command: List[str]):
    for i in range(number):
        start = time.time_ns()
        subprocess.check_call(command)
        end = time.time_ns()
        value = end - start
        add(measurement, key_value, str(value))


def add(measurement: str, key_value: KeyValueList, value: str):
    formatted_kvs = ' '.join([f"{key}={value}" for (key, value) in key_value])
    formatted_measurement = f"{measurement} {time.time()} {value} {formatted_kvs}"
    print(formatted_measurement)

    notes_call = ['git', 'notes', '--ref', PERF_REF,
                  'append', '-m', formatted_measurement]
    subprocess.check_call(notes_call)


def pull():
    fetch()
    reconcile()


def push():
    counter = 0
    while counter < MAX_PUSHES and push_to_origin() != 0:
        pull()
        counter += 1


def push_to_origin() -> int:
    return subprocess.call(['git', 'push', 'origin', PERF_REF])


def fetch():
    subprocess.check_call(['git', 'fetch', 'origin', PERF_REF])


def reconcile():
    subprocess.check_call(['git',
                           'notes',
                           '--ref',
                           PERF_REF,
                           'merge',
                           '-s',
                           'cat_sort_uniq',
                           'FETCH_HEAD'])


def get_raw_notes(max_count_commits: int, offset: int = 0) -> str:
    command = ['git',
               '--no-pager',
               'log',
               '-n', str(max_count_commits),
               '--no-color',
               '--pretty=-- %H%n%N',
               f"--notes={PERF_REF}",
               f"HEAD~{offset}"]
    print(" ".join(command))
    return subprocess.check_output(command, text=True)


def get_df(max_count_commits: int, offset: int = 0):
    import pandas as pd  # type: ignore
    records = []
    commit = None
    for line in get_raw_notes(max_count_commits, offset).splitlines():
        if line.startswith('--'):
            commit = line.split(" ")[1].strip()
            continue
        if len(line.strip()) == 0:
            continue
        if commit is None:
            print(
                f"Already have input but commit is unknown: ''", file=sys.stderr)
            assert(False)
            continue
        data = line.strip()
        items = data.split()
        if len(items) < 3:
            print(
                f"Too few items for commit in input line: '{data}'", file=sys.stderr)
            assert(False)
            continue
        name = items[0]
        time = items[1]
        val = items[2]
        if not isnumeric(val):
            print(
                f"Found non-numeric value '{val}' as measurement "
                f"for commit {commit} in line: '{data}'",
                file=sys.stderr)
            assert(False)
            continue
        kvs = items[3:]
        records.append({"commit": commit, "name": name, "time": pd.to_datetime(
            time, unit='s'), "val": float(val), "kvs": kvs})
    df = pd.DataFrame(records)

    df.index.name = 'num'
    if 'kvs' in df.columns:
        expanded = df.join(df.kvs.explode().str.split('=', expand=True))
        # Only continue if there are indeed kv pairs and not a kvs column of empty arrays
        # TODO(kaihowl) appears when adding only non-kv measurements, maybe handle earlier?
        if 1 in expanded.columns:
            pivoted = expanded.pivot_table(columns=0, index='num', values=1, aggfunc='last')
            df = df.drop(['kvs'], axis=1).join(pivoted)
    return df


def report(max_count: int, output: str):
    import plotly.express as px  # type: ignore
    df = get_df(max_count)
    if 'os' in df.columns and 'runner_os' in df.columns:
        df['os'] = df['os'].fillna(df['runner_os'])
    df = df.fillna("n/a")
    print(df.to_markdown())
    args = {
        'x': 'time',
        'y': 'val',
        'color': 'name',
        'hover_data': df.columns,
    }
    if 'os' in df.columns:
        args['symbol'] = 'os'
    if (len(df) == 0):
        print("No performance measurements found", file=sys.stderr)
        sys.exit(1)
    px.scatter(df, **args).write_html(output)


def filter_df(df, selector: KeyValueList):
    for (key, value) in selector:
        if key not in df.columns:
            raise ValueError(f"Selector '{key}' does not exist")
        df = df[df[key] == value]
    return df


def summarize(df, group_by: str, aggregate_by: str) -> Tuple[float, float]:
    group = df.groupby(group_by).val.agg(aggregate_by)
    return (group.mean(), group.std())


def audit(measurement: str,
          max_count: int,
          group_by: str,
          aggregate_by: str,
          selector: KeyValueList,
          sigma: float):
    df = get_df(max_count, offset=1)
    df_head = get_df(1)
    selector.append(('name', measurement))
    df = filter_df(df, selector)
    df_head = filter_df(df_head, selector)
    print(df.to_markdown())
    mean, std = summarize(df, group_by, aggregate_by)
    print(f"mean: {mean}")
    print(f"std: {std}")
    head_mean, _ = summarize(df_head, group_by, aggregate_by)
    print(f"head_mean: {head_mean}")
    print(f"sigma: {sigma}")
    is_regular = -sigma * std + mean <= head_mean <= mean + sigma * std
    print(f"is regular: {is_regular}")
    sys.exit(not is_regular)


if __name__ == '__main__':
    args = parser.parse_args()
    subcommand = args.subcommand
    del args.subcommand
    locals()[subcommand](**vars(args))
