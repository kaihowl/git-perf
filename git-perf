#!/usr/bin/env python3

import argparse
import time
import subprocess
from typing import List
import sys
import pandas as pd  # type: ignore
import plotly.express as px  # type: ignore

PERF_REF = 'refs/notes/perf'
MAX_PUSHES = 3

# TODO(kaihowl) select perf by kay value

parser = argparse.ArgumentParser()
sub_parser = parser.add_subparsers(dest='subcommand')


def add_measurement_option(parser):
    parser.add_argument(
        '--measurement', '-m', help='Name of measurement', required=True,
        dest='measurement')


def add_kv_option(parser):
    # TODO(kaihowl) validate argument here already with action?
    parser.add_argument(
        '--keyvalue',
        '-kv',
        action='append',
        help='Key-value pair separated by "=" with no whitespaces',
        default=[])


# subcommand: measure
measure_parser = sub_parser.add_parser(
    "measure", help='Measure the supplied commands runtime')
add_kv_option(measure_parser)
add_measurement_option(measure_parser)
measure_parser.add_argument(
    '--number', '-n', help='Number of measurements', type=int, default=1)
measure_parser.add_argument(
    'command', nargs=argparse.REMAINDER, help='Command to measure')

# subcommand: add
add_parser = sub_parser.add_parser('add', help='Add single measurement')
add_kv_option(add_parser)
add_measurement_option(add_parser)
add_parser.add_argument('value')

# subcommand: push
push_parser = sub_parser.add_parser(
    'push', help='Publish performance results to remote')

# subcommand: report
report_parser = sub_parser.add_parser(
    'report', help='Create an HTML performance report')

# subcommand: audit
audit_parser = sub_parser.add_parser(
    'audit', help='Check for perfomance deviations')
add_measurement_option(audit_parser)
# TODO(kaihowl) add validation for kv
audit_parser.add_argument(
    '--selector',
    '-s',
    action='append',
    help='Key-value pair separated by "=" with no whitespaces to subselect measurements',
    default=[])


def measure(measurement: str, number: int, keyvalue: List[str], command: List[str]):
    for i in range(number):
        start = time.time_ns()
        subprocess.check_call(command)
        end = time.time_ns()
        value = end - start
        add(measurement, keyvalue, str(value))


def add(measurement: str, keyvalue: List[str], value: str):
    if not value.isnumeric():
        print(f"Value '{value}' is not numeric", file=sys.stderr)
        sys.exit(1)

    for kv in keyvalue:
        if len(kv.split()) != 1:
            print(f"Key value pair '{kv}' contains whitespace", file=sys.stderr)
            sys.exit(1)

        if len(kv.split('=')) != 2:
            print(f"Key value pair '{kv}' does not follow 'key=value' format", file=sys.stderr)
            sys.exit(1)

    formatted_kvs = ' '.join([kv.strip() for kv in keyvalue])
    formatted_measurement = f"{measurement} {time.time()} {value} {formatted_kvs}"
    print(formatted_measurement)

    notes_call = ['git', 'notes', '--ref', PERF_REF,
                  'append', '-m', formatted_measurement]
    subprocess.check_call(notes_call)


def push():
    counter = 0
    while counter < MAX_PUSHES and push_to_origin() != 0:
        fetch()
        reconcile()
        counter += 1


def push_to_origin() -> int:
    return subprocess.call(['git', 'push', 'origin', PERF_REF])


def fetch():
    subprocess.check_call(['git', 'fetch', 'origin', PERF_REF])


def reconcile():
    subprocess.check_call(['git',
                           'notes',
                           '--ref',
                           PERF_REF,
                           'merge',
                           '-s',
                           'cat_sort_uniq',
                           'FETCH_HEAD'])


def get_raw_notes() -> str:
    command = ['git',
               '--no-pager',
               'log',
               '--no-color',
               '--pretty=-- %H%n%N',
               f"--notes={PERF_REF}"]
    print(" ".join(command))
    return subprocess.check_output(command, text=True)


def get_df():
    records = []
    commit = None
    for line in get_raw_notes().splitlines():
        if line.startswith('--'):
            commit = line.split(" ")[1].strip()
            continue
        if len(line.strip()) == 0:
            continue
        if commit is None:
            print(
                f"Already have input but commit is unknown: ''", file=sys.stderr)
            assert(False)
            continue
        data = line.strip()
        items = data.split()
        if len(items) < 3:
            print(
                f"Too few items for commit in input line: '{data}'", file=sys.stderr)
            assert(False)
            continue
        name = items[0]
        time = items[1]
        val = items[2]
        if not val.isnumeric():
            print(
                f"Found non-numeric value '{val}' as measurement for commit {commit} in line: '{data}'", file=sys.stderr)
            assert(False)
            continue
        kvs = items[3:]
        records.append({"commit": commit, "name": name, "time": pd.to_datetime(
            time, unit='s'), "val": float(val), "kvs": kvs})
    # TODO(kaihowl) handle and test empty records
    df = pd.DataFrame(records)

    df.index.name = 'num'
    df = df.join(df.kvs.explode().str.split(
        '=', expand=True).pivot_table(columns=0, index='num', values=1, aggfunc='last'))
    df = df.drop(['kvs'], axis=1)
    return df


def report():
    df = get_df()
    if 'os' in df.columns and 'runner_os' in df.columns:
        df['os'] = df['os'].fillna(df['runner_os'])
    df = df.fillna("n/a")
    print(df.to_markdown())
    args = {
        'x': 'time',
        'y': 'val',
        'color': 'name',
        'hover_data': df.columns,
    }
    if 'os' in df.columns:
        args['symbol'] = 'os'
    # TODO(kaihowl) make configurable
    px.scatter(df, **args).write_html('result.html')


# TODO(kaihowl) groupby
# TODO(kaihowl) how to pass / select last value? Just use commit on top compared to <n> previous?
def audit(measurement: str, selector: List[str]):
    df = get_df()
    # TODO(kaihowl) selector unused
    print(df[df.name == measurement].val.mean())


if __name__ == '__main__':
    args = parser.parse_args()
    subcommand = args.subcommand
    del args.subcommand
    locals()[subcommand](**vars(args))
